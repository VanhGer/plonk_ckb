//! Generated by capsule
//!
//! `main.rs` is used to define Rust lang items and modules.
//! See `entry.rs` for the `main` function.
//! See `error.rs` for the `Error` type.

#![feature(lang_items)]
#![feature(alloc_error_handler)]
#![feature(panic_info_message)]
#![no_std]
#![cfg_attr(not(test), no_main)]

mod challenge;
mod data_structures;
mod error;
mod verify;

#[cfg(test)]
extern crate alloc;

use crate::data_structures::{CommonPreprocessedInput, Proof, Srs};
use ark_serialize::CanonicalDeserialize;
use ckb_std::ckb_constants::Source;
use ckb_std::debug;
#[cfg(not(test))]
use ckb_std::default_alloc;
use ckb_std::high_level::load_cell_data;
use sha2::Sha256;

use crate::error::Error;

// Embed the Common Preprocessed Input (CPI) and Structured Reference String (SRS) binaries
const CPI: &[u8] = include_bytes!("cpi.bin");
const SRS: &[u8] = include_bytes!("srs.bin");

#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!(4 * 1024, 2048 * 1024, 64);

/// The entry point of the CKB contract program.
///
/// This function is the main entry point of the contract and is invoked by the CKB-VM.
/// It performs the following tasks:
/// - Loads proof data from the cell.
/// - Deserializes the proof data.
/// - Deserializes the Common Preprocessed Input (CPI) and Structured Reference String (SRS).
/// - Verifies the proof using the deserialized CPI and SRS.
/// - Returns an error code if any step fails.
///
/// # Returns
///
/// An `i8` error code where 0 indicates success and non-zero indicates an error.
/// The possible error codes are defined in the `Error` enum.
fn program_entry() -> i8 {
    // Load the proof data from the first output cell
    debug!("Loading proof data...");
    let proof_data = match load_cell_data(0, Source::Output) {
        Ok(data) => data,
        Err(_) => return Error::LoadingCell as i8,
    };
    debug!("Proof data length: {:?}", proof_data.len());

    // Deserialize the proof data
    debug!("Deserializing proof data...");
    let proof = match Proof::deserialize_uncompressed_unchecked(&proof_data[..]) {
        Ok(data) => data,
        Err(_) => return Error::Encoding as i8,
    };

    // Deserialize the Common Preprocessed Input (CPI)
    debug!("Deserializing CPI...");
    let cpi = match CommonPreprocessedInput::deserialize_uncompressed_unchecked(CPI) {
        Ok(data) => data,
        Err(e) => {
            debug!("{:?}", e);
            return Error::Encoding as i8;
        }
    };

    // Deserialize the Structured Reference String (SRS)
    debug!("Deserializing SRS...");
    let srs = match Srs::deserialize_uncompressed_unchecked(SRS) {
        Ok(data) => data,
        Err(e) => {
            debug!("{:?}", e);
            return Error::Encoding as i8;
        }
    };

    // Verify the proof using the deserialized CPI and SRS
    debug!("Verifying proof...");
    match verify::plonk_verify::<Sha256>(proof, cpi, srs) {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}
